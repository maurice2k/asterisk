{
  "openapi": "3.1.2",
  "info": {
    "title": "Asterisk REST Interface (ARI)",
    "description": "REST interface for Asterisk.",
    "version": "12.0.0",
    "license": {
      "name": "GPL-2.0",
      "url": "https://www.gnu.org/licenses/old-licenses/gpl-2.0.html"
    },
    "x-copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
    "x-author": "David M. Lee, II <dlee@digium.com>"
  },
  "servers": [
    {
      "url": "http://localhost:8088/ari",
      "description": "Asterisk ARI server"
    }
  ],
  "tags": [
    {
      "name": "asterisk",
      "description": "Asterisk resources"
    },
    {
      "name": "endpoints",
      "description": "Endpoint resources"
    },
    {
      "name": "channels",
      "description": "Channel resources"
    },
    {
      "name": "bridges",
      "description": "Bridge resources"
    },
    {
      "name": "recordings",
      "description": "Recording resources"
    },
    {
      "name": "sounds",
      "description": "Sound resources"
    },
    {
      "name": "playbacks",
      "description": "Playback control resources"
    },
    {
      "name": "deviceStates",
      "description": "Device state resources",
      "x-author": "Kevin Harwell <kharwell@digium.com>"
    },
    {
      "name": "mailboxes",
      "description": "Mailboxes resources",
      "x-copyright": "Copyright (C) 2013, Digium, Inc.",
      "x-author": "Jonathan Rose <jrose@digium.com>"
    },
    {
      "name": "events",
      "description": "WebSocket resource"
    },
    {
      "name": "applications",
      "description": "Stasis application resources",
      "x-copyright": "Copyright (C) 2013, Digium, Inc."
    }
  ],
  "paths": {
    "/asterisk/config/dynamic/{configClass}/{objectType}/{id}": {
      "description": "Asterisk dynamic configuration",
      "get": {
        "summary": "Retrieve a dynamic configuration object.",
        "operationId": "asterisk_getObject",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "configClass",
            "in": "path",
            "description": "The configuration class containing dynamic configuration objects.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectType",
            "in": "path",
            "description": "The type of configuration object to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the object to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConfigTuple"
                  }
                }
              }
            }
          },
          "404": {
            "description": "{configClass|objectType|id} not found"
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "put": {
        "summary": "Create or update a dynamic configuration object.",
        "operationId": "asterisk_updateObject",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "configClass",
            "in": "path",
            "description": "The configuration class containing dynamic configuration objects.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectType",
            "in": "path",
            "description": "The type of configuration object to create or update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the object to create or update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "fields",
          "x-param-insert-after": "id",
          "description": "The body object should have a value that is a list of ConfigTuples, which provide the fields to update. Ex. [ { \"attribute\": \"directmedia\", \"value\": \"false\" } ]"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConfigTuple"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request body"
          },
          "403": {
            "description": "Could not create or update object"
          },
          "404": {
            "description": "{configClass|objectType} not found"
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "delete": {
        "summary": "Delete a dynamic configuration object.",
        "operationId": "asterisk_deleteObject",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "configClass",
            "in": "path",
            "description": "The configuration class containing dynamic configuration objects.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectType",
            "in": "path",
            "description": "The type of configuration object to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the object to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "403": {
            "description": "Could not delete object"
          },
          "404": {
            "description": "{configClass|objectType|id} not found"
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/info": {
      "description": "Asterisk system information (similar to core show settings)",
      "get": {
        "summary": "Gets Asterisk system information.",
        "operationId": "asterisk_getInfo",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "only",
            "in": "query",
            "description": "Filter information returned",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "build",
                  "system",
                  "config",
                  "status"
                ]
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsteriskInfo"
                }
              }
            }
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/ping": {
      "description": "Asterisk ping",
      "get": {
        "summary": "Response pong message.",
        "operationId": "asterisk_ping",
        "x-version-added": "13.25.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AsteriskPing"
                }
              }
            }
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/modules": {
      "description": "Asterisk modules",
      "get": {
        "summary": "List Asterisk modules.",
        "operationId": "asterisk_listModules",
        "x-version-added": "13.5.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Module"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/modules/{moduleName}": {
      "description": "Asterisk module",
      "get": {
        "summary": "Get Asterisk module information.",
        "operationId": "asterisk_getModule",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "moduleName",
            "in": "path",
            "description": "Module's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Module"
                }
              }
            }
          },
          "404": {
            "description": "Module could not be found in running modules."
          },
          "409": {
            "description": "Module information could not be retrieved."
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "post": {
        "summary": "Load an Asterisk module.",
        "operationId": "asterisk_loadModule",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "moduleName",
            "in": "path",
            "description": "Module's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "409": {
            "description": "Module could not be loaded."
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "delete": {
        "summary": "Unload an Asterisk module.",
        "operationId": "asterisk_unloadModule",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "moduleName",
            "in": "path",
            "description": "Module's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Module not found in running modules."
          },
          "409": {
            "description": "Module could not be unloaded."
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "put": {
        "summary": "Reload an Asterisk module.",
        "operationId": "asterisk_reloadModule",
        "x-version-added": "13.5.0",
        "parameters": [
          {
            "name": "moduleName",
            "in": "path",
            "description": "Module's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Module not found in running modules."
          },
          "409": {
            "description": "Module could not be reloaded."
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/logging": {
      "description": "Asterisk log channels",
      "get": {
        "summary": "Gets Asterisk log channel information.",
        "operationId": "asterisk_listLogChannels",
        "x-version-added": "13.6.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LogChannel"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/logging/{logChannelName}": {
      "description": "Asterisk log channel",
      "post": {
        "summary": "Adds a log channel.",
        "operationId": "asterisk_addLog",
        "x-version-added": "13.6.0",
        "parameters": [
          {
            "name": "logChannelName",
            "in": "path",
            "description": "The log channel to add",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "configuration",
            "in": "query",
            "description": "levels of the log channel",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad request body"
          },
          "409": {
            "description": "Log channel could not be created."
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "delete": {
        "summary": "Deletes a log channel.",
        "operationId": "asterisk_deleteLog",
        "x-version-added": "13.6.0",
        "parameters": [
          {
            "name": "logChannelName",
            "in": "path",
            "description": "Log channels name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Log channel does not exist."
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/logging/{logChannelName}/rotate": {
      "description": "Asterisk log channel",
      "put": {
        "summary": "Rotates a log channel.",
        "operationId": "asterisk_rotateLog",
        "x-version-added": "13.6.0",
        "parameters": [
          {
            "name": "logChannelName",
            "in": "path",
            "description": "Log channel's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Log channel does not exist."
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/asterisk/variable": {
      "description": "Global variables",
      "get": {
        "summary": "Get the value of a global variable.",
        "operationId": "asterisk_getGlobalVar",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "variable",
            "in": "query",
            "description": "The variable to get",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Variable"
                }
              }
            }
          },
          "400": {
            "description": "Missing variable parameter."
          }
        },
        "tags": [
          "asterisk"
        ]
      },
      "post": {
        "summary": "Set the value of a global variable.",
        "operationId": "asterisk_setGlobalVar",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "variable",
            "in": "query",
            "description": "The variable to set",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "value",
            "in": "query",
            "description": "The value to set the variable to",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Missing variable parameter."
          }
        },
        "tags": [
          "asterisk"
        ]
      }
    },
    "/endpoints": {
      "description": "Asterisk endpoints",
      "get": {
        "summary": "List all endpoints.",
        "operationId": "endpoints_list",
        "x-version-added": "12.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Endpoint"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/sendMessage": {
      "description": "Send a message to some technology URI or endpoint.",
      "put": {
        "summary": "Send a message to some technology URI or endpoint.",
        "operationId": "endpoints_sendMessage",
        "x-version-added": "13.0.0",
        "parameters": [
          {
            "name": "to",
            "in": "query",
            "description": "The endpoint resource or technology specific URI to send the message to. Valid resources are pjsip, and xmpp.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "The endpoint resource or technology specific identity to send this message from. Valid resources are pjsip, and xmpp.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "body",
            "in": "query",
            "description": "The body of the message",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "body",
          "description": "The \"variables\" key in the body object holds technology specific key/value pairs to append to the message. These can be interpreted and used by the various resource types; for example, pjsip and sip resource types will add the key/value pairs as SIP headers,"
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Invalid parameters for sending a message."
          },
          "404": {
            "description": "Endpoint not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/refer": {
      "description": "Refer an endpoint or technology URI to some technology URI or endpoint.",
      "post": {
        "summary": "Refer an endpoint or technology URI to some technology URI or endpoint.",
        "operationId": "endpoints_refer",
        "x-version-added": "18.20.0",
        "parameters": [
          {
            "name": "to",
            "in": "query",
            "description": "The endpoint resource or technology specific URI that should be referred to somewhere. Valid resource is pjsip.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "The endpoint resource or technology specific identity to refer from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "refer_to",
            "in": "query",
            "description": "The endpoint resource or technology specific URI to refer to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "to_self",
            "in": "query",
            "description": "If true and \"refer_to\" refers to an Asterisk endpoint, the \"refer_to\" value is set to point to this Asterisk endpoint - so the referee is referred to Asterisk. Otherwise, use the contact URI associated with the endpoint.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "to_self",
          "description": "The \"variables\" key in the body object holds technology specific key/value pairs to append to the message. These can be interpreted and used by the various resource types; for example, the pjsip resource type will add the key/value pairs as SIP headers. The \"display_name\" key is used by the PJSIP technology. Its value will be prepended as a display name to the Refer-To URI."
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Invalid parameters for referring."
          },
          "404": {
            "description": "Endpoint not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/{tech}": {
      "description": "Asterisk endpoints",
      "get": {
        "summary": "List available endoints for a given endpoint technology.",
        "operationId": "endpoints_listByTech",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "tech",
            "in": "path",
            "description": "Technology of the endpoints (pjsip,iax2,...)",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Endpoint"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Endpoints not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/{tech}/{resource}": {
      "description": "Single endpoint",
      "get": {
        "summary": "Details for an endpoint.",
        "operationId": "endpoints_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "tech",
            "in": "path",
            "description": "Technology of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resource",
            "in": "path",
            "description": "ID of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Endpoint"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters for sending a message."
          },
          "404": {
            "description": "Endpoints not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/{tech}/{resource}/sendMessage": {
      "description": "Send a message to some endpoint in a technology.",
      "put": {
        "summary": "Send a message to some endpoint in a technology.",
        "operationId": "endpoints_sendMessageToEndpoint",
        "x-version-added": "13.0.0",
        "parameters": [
          {
            "name": "tech",
            "in": "path",
            "description": "Technology of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resource",
            "in": "path",
            "description": "ID of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "The endpoint resource or technology specific identity to send this message from. Valid resources are pjsip and xmpp.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "body",
            "in": "query",
            "description": "The body of the message",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "body",
          "description": "The \"variables\" key in the body object holds technology specific key/value pairs to append to the message. These can be interpreted and used by the various resource types; for example, pjsip and sip resource types will add the key/value pairs as SIP headers,"
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Invalid parameters for sending a message."
          },
          "404": {
            "description": "Endpoint not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/endpoints/{tech}/{resource}/refer": {
      "description": "Refer an endpoint in a technology to some technology URI or endpoint..",
      "post": {
        "summary": "Refer an endpoint or technology URI to some technology URI or endpoint.",
        "operationId": "endpoints_referToEndpoint",
        "x-version-added": "18.20.0",
        "parameters": [
          {
            "name": "tech",
            "in": "path",
            "description": "Technology of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resource",
            "in": "path",
            "description": "ID of the endpoint",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "The endpoint resource or technology specific identity to refer from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "refer_to",
            "in": "query",
            "description": "The endpoint resource or technology specific URI to refer to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "to_self",
            "in": "query",
            "description": "If true and \"refer_to\" refers to an Asterisk endpoint, the \"refer_to\" value is set to point to this Asterisk endpoint - so the referee is referred to Asterisk. Otherwise, use the contact URI associated with the endpoint.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "to_self",
          "description": "The \"variables\" key in the body object holds technology specific key/value pairs to append to the message. These can be interpreted and used by the various resource types; for example, the pjsip resource type will add the key/value pairs as SIP headers,"
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Invalid parameters for referring."
          },
          "404": {
            "description": "Endpoint not found"
          }
        },
        "tags": [
          "endpoints"
        ]
      }
    },
    "/channels": {
      "description": "Active channels",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "get": {
        "summary": "List all active channels in Asterisk.",
        "operationId": "channels_list",
        "x-version-added": "12.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Channel"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "channels"
        ]
      },
      "post": {
        "summary": "Create a new channel (originate).",
        "operationId": "channels_originate",
        "description": "The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "endpoint",
            "in": "query",
            "description": "Endpoint to call.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "extension",
            "in": "query",
            "description": "The extension to dial after the endpoint answers. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "context",
            "in": "query",
            "description": "The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "priority",
            "in": "query",
            "description": "The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "label",
            "in": "query",
            "description": "The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "callerId",
            "in": "query",
            "description": "CallerID to use when dialing the endpoint or extension.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Timeout (in seconds) before giving up dialing, or -1 for no timeout.",
            "schema": {
              "type": "integer",
              "default": 30
            }
          },
          {
            "name": "channelId",
            "in": "query",
            "description": "The unique id to assign the channel on creation.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "otherChannelId",
            "in": "query",
            "description": "The unique id to assign the second channel when using local channels.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "originator",
            "in": "query",
            "description": "The unique id of the channel which is originating this one.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formats",
            "in": "query",
            "description": "The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "timeout",
          "description": "The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters for originating a channel."
          },
          "409": {
            "description": "Channel with given unique ID already exists."
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/create": {
      "description": "Create a channel and place it in a Stasis app, but do not dial the channel yet.",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Create channel.",
        "operationId": "channels_create",
        "x-version-added": "14.0.0",
        "parameters": [
          {
            "name": "endpoint",
            "in": "query",
            "description": "Endpoint for channel communication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "Stasis Application to place channel into",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "channelId",
            "in": "query",
            "description": "The unique id to assign the channel on creation.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "otherChannelId",
            "in": "query",
            "description": "The unique id to assign the second channel when using local channels.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "originator",
            "in": "query",
            "description": "Unique ID of the calling channel",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formats",
            "in": "query",
            "description": "The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "formats",
          "description": "The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "409": {
            "description": "Channel with given unique ID already exists."
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}": {
      "description": "Active channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "get": {
        "summary": "Channel details.",
        "operationId": "channels_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "404": {
            "description": "Channel not found"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "post": {
        "summary": "Create a new channel (originate with id).",
        "operationId": "channels_originateWithId",
        "description": "The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.",
        "x-version-added": "12.2.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique id to assign the channel on creation.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "endpoint",
            "in": "query",
            "description": "Endpoint to call.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "extension",
            "in": "query",
            "description": "The extension to dial after the endpoint answers. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "context",
            "in": "query",
            "description": "The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "priority",
            "in": "query",
            "description": "The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "label",
            "in": "query",
            "description": "The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "callerId",
            "in": "query",
            "description": "CallerID to use when dialing the endpoint or extension.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Timeout (in seconds) before giving up dialing, or -1 for no timeout.",
            "schema": {
              "type": "integer",
              "default": 30
            }
          },
          {
            "name": "otherChannelId",
            "in": "query",
            "description": "The unique id to assign the second channel when using local channels.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "originator",
            "in": "query",
            "description": "The unique id of the channel which is originating this one.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formats",
            "in": "query",
            "description": "The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "timeout",
          "description": "The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters for originating a channel."
          },
          "409": {
            "description": "Channel with given unique ID already exists."
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Delete (i.e. hangup) a channel.",
        "operationId": "channels_hangup",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "reason_code",
            "in": "query",
            "description": "The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://docs.asterisk.org/Configuration/Miscellaneous/Hangup-Cause-Mappings/",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "reason",
            "in": "query",
            "description": "Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.",
            "schema": {
              "type": "string",
              "enum": [
                "normal",
                "busy",
                "congestion",
                "no_answer",
                "timeout",
                "rejected",
                "unallocated",
                "normal_unspecified",
                "number_incomplete",
                "codec_mismatch",
                "interworking",
                "failure",
                "answered_elsewhere"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Invalid reason for hangup provided"
          },
          "404": {
            "description": "Channel not found"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/continue": {
      "description": "Exit application; continue execution in the dialplan",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Exit application; continue execution in the dialplan.",
        "operationId": "channels_continueInDialplan",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "context",
            "in": "query",
            "description": "The context to continue to.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "extension",
            "in": "query",
            "description": "The extension to continue to.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "priority",
            "in": "query",
            "description": "The priority to continue to.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "label",
            "in": "query",
            "description": "The label to continue to - will supersede 'priority' if both are provided.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/move": {
      "description": "Move the channel from one Stasis application to another.",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Move the channel from one Stasis application to another.",
        "operationId": "channels_move",
        "x-version-added": "13.26.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "The channel will be passed to this Stasis application.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application provided by 'app'.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/redirect": {
      "description": "Inform the channel that it should redirect itself to a different location. Note that this will almost certainly cause the channel to exit the application.",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Redirect the channel to a different location.",
        "operationId": "channels_redirect",
        "x-version-added": "13.3.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "endpoint",
            "in": "query",
            "description": "The endpoint to redirect the channel to",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Endpoint parameter not provided"
          },
          "404": {
            "description": "Channel or endpoint not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "422": {
            "description": "Endpoint is not the same type as the channel"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/answer": {
      "description": "Answer a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Answer a channel.",
        "operationId": "channels_answer",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/ring": {
      "description": "Send a ringing indication to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Indicate ringing to a channel.",
        "operationId": "channels_ring",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Stop ringing indication on a channel if locally generated.",
        "operationId": "channels_ringStop",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/progress": {
      "description": "Indicate progress on a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Indicate progress on a channel.",
        "operationId": "channels_progress",
        "x-version-added": "22.6.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/dtmf": {
      "description": "Send DTMF to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Send provided DTMF to a given channel.",
        "operationId": "channels_sendDTMF",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dtmf",
            "in": "query",
            "description": "DTMF To send.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "before",
            "in": "query",
            "description": "Amount of time to wait before DTMF digits (specified in milliseconds) start.",
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "between",
            "in": "query",
            "description": "Amount of time in between DTMF digits (specified in milliseconds).",
            "schema": {
              "type": "integer",
              "default": 100
            }
          },
          {
            "name": "duration",
            "in": "query",
            "description": "Length of each DTMF digit (specified in milliseconds).",
            "schema": {
              "type": "integer",
              "default": 100
            }
          },
          {
            "name": "after",
            "in": "query",
            "description": "Amount of time to wait after DTMF digits (specified in milliseconds) end.",
            "schema": {
              "type": "integer",
              "default": 0
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "DTMF is required"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/mute": {
      "description": "Mute a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Mute a channel.",
        "operationId": "channels_mute",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "direction",
            "in": "query",
            "description": "Direction in which to mute audio",
            "schema": {
              "type": "string",
              "enum": [
                "both",
                "in",
                "out"
              ],
              "default": "both"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Unmute a channel.",
        "operationId": "channels_unmute",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "direction",
            "in": "query",
            "description": "Direction in which to unmute audio",
            "schema": {
              "type": "string",
              "enum": [
                "both",
                "in",
                "out"
              ],
              "default": "both"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/hold": {
      "description": "Put a channel on hold",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Hold a channel.",
        "operationId": "channels_hold",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Remove a channel from hold.",
        "operationId": "channels_unhold",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/moh": {
      "description": "Play music on hold to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Play music on hold to a channel.",
        "operationId": "channels_startMoh",
        "description": "Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "mohClass",
            "in": "query",
            "description": "Music on hold class to use",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Stop playing music on hold to a channel.",
        "operationId": "channels_stopMoh",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/silence": {
      "description": "Play silence to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Play silence to a channel.",
        "operationId": "channels_startSilence",
        "description": "Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "delete": {
        "summary": "Stop playing silence to a channel.",
        "operationId": "channels_stopSilence",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/play": {
      "description": "Play media to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start playback of media.",
        "operationId": "channels_play",
        "description": "The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "media",
            "in": "query",
            "description": "Media URIs to play.",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "lang",
            "in": "query",
            "description": "For sounds, selects language for sound.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offsetms",
            "in": "query",
            "description": "Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "skipms",
            "in": "query",
            "description": "Number of milliseconds to skip for forward/reverse operations.",
            "schema": {
              "type": "integer",
              "default": 3000
            }
          },
          {
            "name": "playbackId",
            "in": "query",
            "description": "Playback ID.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playback"
                }
              }
            }
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/play/{playbackId}": {
      "description": "Play media to a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start playback of media and specify the playbackId.",
        "operationId": "channels_playWithId",
        "description": "The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)",
        "x-version-added": "12.2.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbackId",
            "in": "path",
            "description": "Playback ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "media",
            "in": "query",
            "description": "Media URIs to play.",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "lang",
            "in": "query",
            "description": "For sounds, selects language for sound.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offsetms",
            "in": "query",
            "description": "Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "skipms",
            "in": "query",
            "description": "Number of milliseconds to skip for forward/reverse operations.",
            "schema": {
              "type": "integer",
              "default": 3000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playback"
                }
              }
            }
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/record": {
      "description": "Record audio from a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start a recording.",
        "operationId": "channels_record",
        "description": "Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Recording's filename",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Format to encode audio in",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maxDurationSeconds",
            "in": "query",
            "description": "Maximum duration of the recording, in seconds. 0 for no limit",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "maxSilenceSeconds",
            "in": "query",
            "description": "Maximum duration of silence, in seconds. 0 for no limit",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "ifExists",
            "in": "query",
            "description": "Action to take if a recording with the same name already exists.",
            "schema": {
              "type": "string",
              "enum": [
                "fail",
                "overwrite",
                "append"
              ],
              "default": "fail"
            }
          },
          {
            "name": "beep",
            "in": "query",
            "description": "Play beep when recording begins",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "terminateOn",
            "in": "query",
            "description": "DTMF input to terminate recording",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "any",
                "*",
                "#"
              ],
              "default": "none"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveRecording"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters"
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel is not in a Stasis application; the channel is currently bridged with other channels; A recording with the same name already exists on the system and can not be overwritten because it is in progress or ifExists=fail"
          },
          "422": {
            "description": "The format specified is unknown on this system"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/variable": {
      "description": "Variables on a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "get": {
        "summary": "Get the value of a channel variable or function.",
        "operationId": "channels_getChannelVar",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "variable",
            "in": "query",
            "description": "The channel variable or function to get",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Variable"
                }
              }
            }
          },
          "400": {
            "description": "Missing variable parameter."
          },
          "404": {
            "description": "Channel or variable not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          }
        },
        "tags": [
          "channels"
        ]
      },
      "post": {
        "summary": "Set the value of a channel variable or function.",
        "operationId": "channels_setChannelVar",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "variable",
            "in": "query",
            "description": "The channel variable or function to set",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "value",
            "in": "query",
            "description": "The value to set the variable to",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Missing variable parameter."
          },
          "404": {
            "description": "Channel not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/snoop": {
      "description": "Snoop (spy/whisper) on a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start snooping.",
        "operationId": "channels_snoopChannel",
        "description": "Snoop (spy/whisper) on a specific channel.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "spy",
            "in": "query",
            "description": "Direction of audio to spy on",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "both",
                "out",
                "in"
              ],
              "default": "none"
            }
          },
          {
            "name": "whisper",
            "in": "query",
            "description": "Direction of audio to whisper into",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "both",
                "out",
                "in"
              ],
              "default": "none"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "Application the snooping channel is placed into",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "snoopId",
            "in": "query",
            "description": "Unique ID to assign to snooping channel",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters"
          },
          "404": {
            "description": "Channel not found"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/snoop/{snoopId}": {
      "description": "Snoop (spy/whisper) on a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start snooping.",
        "operationId": "channels_snoopChannelWithId",
        "description": "Snoop (spy/whisper) on a specific channel.",
        "x-version-added": "12.2.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "snoopId",
            "in": "path",
            "description": "Unique ID to assign to snooping channel",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "spy",
            "in": "query",
            "description": "Direction of audio to spy on",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "both",
                "out",
                "in"
              ],
              "default": "none"
            }
          },
          {
            "name": "whisper",
            "in": "query",
            "description": "Direction of audio to whisper into",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "both",
                "out",
                "in"
              ],
              "default": "none"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "Application the snooping channel is placed into",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "appArgs",
            "in": "query",
            "description": "The application arguments to pass to the Stasis application",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters"
          },
          "404": {
            "description": "Channel not found"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/dial": {
      "description": "Dial a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Dial a created channel.",
        "operationId": "channels_dial",
        "x-version-added": "14.0.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "caller",
            "in": "query",
            "description": "Channel ID of caller",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Dial timeout",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Channel cannot be found."
          },
          "409": {
            "description": "Channel cannot be dialed."
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/rtp_statistics": {
      "description": "Get RTP statistics information for RTP on a channel",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "get": {
        "summary": "RTP stats on a channel.",
        "operationId": "channels_rtpstatistics",
        "x-version-added": "13.27.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RTPstat"
                }
              }
            }
          },
          "404": {
            "description": "Channel cannot be found."
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/externalMedia": {
      "description": "Create a channel to an External Media source/sink.",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Start an External Media session.",
        "operationId": "channels_externalMedia",
        "description": "Create a channel to an External Media source/sink.  The combination of transport and encapsulation will select one of chan_rtp(udp/rtp), chan_audiosocket(tcp/audiosocket) or chan_websocket(websocket/none) channel drivers.",
        "x-version-added": "16.6.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "query",
            "description": "The unique id to assign the channel on creation.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "app",
            "in": "query",
            "description": "Stasis Application to place channel into",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "external_host",
            "in": "query",
            "description": "Hostname/ip:port or websocket_client connection ID of external host.  May be empty for a websocket server connection.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "encapsulation",
            "in": "query",
            "description": "Payload encapsulation protocol.  Must be 'none' for the websocket transport.",
            "schema": {
              "type": "string",
              "enum": [
                "rtp",
                "audiosocket",
                "none"
              ],
              "default": "rtp"
            }
          },
          {
            "name": "transport",
            "in": "query",
            "description": "Transport protocol",
            "schema": {
              "type": "string",
              "enum": [
                "udp",
                "tcp",
                "websocket"
              ],
              "default": "udp"
            }
          },
          {
            "name": "connection_type",
            "in": "query",
            "description": "Connection type (client/server). 'server' is only valid for the websocket transport.",
            "schema": {
              "type": "string",
              "enum": [
                "client",
                "server"
              ],
              "default": "client"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Format to encode audio in",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "direction",
            "in": "query",
            "description": "External media direction",
            "schema": {
              "type": "string",
              "enum": [
                "both"
              ],
              "default": "both"
            }
          },
          {
            "name": "data",
            "in": "query",
            "description": "An arbitrary data field",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "transport_data",
            "in": "query",
            "description": "Transport-specific data. For websocket this is appended to the dialstring.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "app",
          "description": "The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Channel"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters"
          },
          "409": {
            "description": "Channel is not in a Stasis application; Channel is already bridged"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/channels/{channelId}/transfer_progress": {
      "description": "Inform the channel that the transfer is in progress.",
      "x-requires-modules": [
        "res_stasis_answer",
        "res_stasis_playback",
        "res_stasis_recording",
        "res_stasis_snoop"
      ],
      "post": {
        "summary": "Inform the channel about the progress of the attended/blind transfer.",
        "operationId": "channels_transfer_progress",
        "x-version-added": "22.3.0",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "states",
            "in": "query",
            "description": "The state of the progress",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Endpoint parameter not provided"
          },
          "404": {
            "description": "Channel or endpoint not found"
          },
          "409": {
            "description": "Channel not in a Stasis application"
          },
          "412": {
            "description": "Channel in invalid state"
          }
        },
        "tags": [
          "channels"
        ]
      }
    },
    "/bridges": {
      "description": "Active bridges",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "get": {
        "summary": "List all active bridges in Asterisk.",
        "operationId": "bridges_list",
        "x-version-added": "12.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Bridge"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "bridges"
        ]
      },
      "post": {
        "summary": "Create a new bridge.",
        "operationId": "bridges_create",
        "description": "This bridge persists until it has been shut down, or Asterisk has been shut down.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single, sdp_label).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bridgeId",
            "in": "query",
            "description": "Unique ID to give to the bridge being created.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Name to give to the bridge being created.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Bridge"
                }
              }
            }
          },
          "409": {
            "description": "Bridge with the same bridgeId already exists"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}": {
      "description": "Individual bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Create a new bridge.",
        "operationId": "bridges_createWithId",
        "description": "This bridge persists until it has been shut down, or Asterisk has been shut down.",
        "x-version-added": "12.2.0",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single, sdp_label) to set.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Unique ID to give to the bridge being created.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Set the name of the bridge.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Bridge"
                }
              }
            }
          },
          "409": {
            "description": "Bridge with the same bridgeId already exists"
          }
        },
        "tags": [
          "bridges"
        ]
      },
      "get": {
        "summary": "Get bridge details.",
        "operationId": "bridges_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Bridge"
                }
              }
            }
          },
          "404": {
            "description": "Bridge not found"
          }
        },
        "tags": [
          "bridges"
        ]
      },
      "delete": {
        "summary": "Shut down a bridge.",
        "operationId": "bridges_destroy",
        "description": "If any channels are in this bridge, they will be removed and resume whatever they were doing beforehand.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Bridge not found"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/addChannel": {
      "description": "Add a channel to a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Add a channel to a bridge.",
        "operationId": "bridges_addChannel",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "channel",
            "in": "query",
            "description": "Ids of channels to add to bridge",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "role",
            "in": "query",
            "description": "Channel's role in the bridge",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "absorbDTMF",
            "in": "query",
            "description": "Absorb DTMF coming from this channel, preventing it to pass through to the bridge",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "mute",
            "in": "query",
            "description": "Mute audio from this channel, preventing it to pass through to the bridge",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "inhibitConnectedLineUpdates",
            "in": "query",
            "description": "Do not present the identity of the newly connected channel to other bridge members",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Channel not found"
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in Stasis application; Channel currently recording"
          },
          "422": {
            "description": "Channel not in Stasis application"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/removeChannel": {
      "description": "Remove a channel from a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Remove a channel from a bridge.",
        "operationId": "bridges_removeChannel",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "channel",
            "in": "query",
            "description": "Ids of channels to remove from bridge",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Channel not found"
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in Stasis application"
          },
          "422": {
            "description": "Channel not in this bridge"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/videoSource/{channelId}": {
      "description": "Set a channel as the video source in a multi-party bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.",
        "operationId": "bridges_setVideoSource",
        "x-version-added": "13.13.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "channelId",
            "in": "path",
            "description": "Channel's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Bridge or Channel not found"
          },
          "409": {
            "description": "Channel not in Stasis application"
          },
          "422": {
            "description": "Channel not in this Bridge"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/videoSource": {
      "description": "Removes any explicit video source",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "delete": {
        "summary": "Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.",
        "operationId": "bridges_clearVideoSource",
        "x-version-added": "13.13.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Bridge not found"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/moh": {
      "description": "Play music on hold to a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Play music on hold to a bridge or change the MOH class that is playing.",
        "operationId": "bridges_startMoh",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "mohClass",
            "in": "query",
            "description": "Channel's id",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in Stasis application"
          }
        },
        "tags": [
          "bridges"
        ]
      },
      "delete": {
        "summary": "Stop playing music on hold to a bridge.",
        "operationId": "bridges_stopMoh",
        "description": "This will only stop music on hold being played via POST bridges/{bridgeId}/moh.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in Stasis application"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/play": {
      "description": "Play media to the participants of a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Start playback of media on a bridge.",
        "operationId": "bridges_play",
        "description": "The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "media",
            "in": "query",
            "description": "Media URIs to play.",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "announcer_format",
            "in": "query",
            "description": "Format of the 'Anouncer' channel attached to the bridge. Defaults to the format of the channel in the bridge with the highest sampe rate.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "lang",
            "in": "query",
            "description": "For sounds, selects language for sound.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offsetms",
            "in": "query",
            "description": "Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "skipms",
            "in": "query",
            "description": "Number of milliseconds to skip for forward/reverse operations.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 3000
            }
          },
          {
            "name": "playbackId",
            "in": "query",
            "description": "Playback Id.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playback"
                }
              }
            }
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in a Stasis application"
          },
          "422": {
            "description": "The format specified is unknown on this system"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/play/{playbackId}": {
      "description": "Play media to a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Start playback of media on a bridge.",
        "operationId": "bridges_playWithId",
        "description": "The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)",
        "x-version-added": "12.3.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbackId",
            "in": "path",
            "description": "Playback ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "media",
            "in": "query",
            "description": "Media URIs to play.",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "announcer_format",
            "in": "query",
            "description": "Format of the 'Anouncer' channel attached to the bridge. Defaults to the format of the channel in the bridge with the highest sampe rate.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "lang",
            "in": "query",
            "description": "For sounds, selects language for sound.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offsetms",
            "in": "query",
            "description": "Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "skipms",
            "in": "query",
            "description": "Number of milliseconds to skip for forward/reverse operations.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 3000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playback"
                }
              }
            }
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge not in a Stasis application"
          },
          "422": {
            "description": "The format specified is unknown on this system"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/bridges/{bridgeId}/record": {
      "description": "Record audio on a bridge",
      "x-requires-modules": [
        "res_stasis_recording",
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Start a recording.",
        "operationId": "bridges_record",
        "description": "This records the mixed audio from all channels participating in this bridge.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "bridgeId",
            "in": "path",
            "description": "Bridge's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Recording's filename",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Format to encode audio in",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "recorder_format",
            "in": "query",
            "description": "Format of the 'Recorder' channel attached to the bridge. Defaults to the same format as the 'format' parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maxDurationSeconds",
            "in": "query",
            "description": "Maximum duration of the recording, in seconds. 0 for no limit.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "maxSilenceSeconds",
            "in": "query",
            "description": "Maximum duration of silence, in seconds. 0 for no limit.",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "ifExists",
            "in": "query",
            "description": "Action to take if a recording with the same name already exists.",
            "schema": {
              "type": "string",
              "enum": [
                "fail",
                "overwrite",
                "append"
              ],
              "default": "fail"
            }
          },
          {
            "name": "beep",
            "in": "query",
            "description": "Play beep when recording begins",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "terminateOn",
            "in": "query",
            "description": "DTMF input to terminate recording.",
            "schema": {
              "type": "string",
              "enum": [
                "none",
                "any",
                "*",
                "#"
              ],
              "default": "none"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveRecording"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters"
          },
          "404": {
            "description": "Bridge not found"
          },
          "409": {
            "description": "Bridge is not in a Stasis application; A recording with the same name already exists on the system and can not be overwritten because it is in progress or ifExists=fail"
          },
          "422": {
            "description": "The format specified is unknown on this system"
          }
        },
        "tags": [
          "bridges"
        ]
      }
    },
    "/recordings/stored": {
      "description": "Recordings",
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "get": {
        "summary": "List recordings that are complete.",
        "operationId": "recordings_listStored",
        "x-version-added": "12.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StoredRecording"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/stored/{recordingName}": {
      "description": "Individual recording",
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "get": {
        "summary": "Get a stored recording's details.",
        "operationId": "recordings_getStored",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoredRecording"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      },
      "delete": {
        "summary": "Delete a stored recording.",
        "operationId": "recordings_deleteStored",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/stored/{recordingName}/file": {
      "description": "The actual file associated with the stored recording",
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "get": {
        "summary": "Get the file associated with the stored recording.",
        "operationId": "recordings_getStoredFile",
        "x-version-added": "14.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "403": {
            "description": "The recording file could not be opened"
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/stored/{recordingName}/copy": {
      "description": "Copy an individual recording",
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "post": {
        "summary": "Copy a stored recording.",
        "operationId": "recordings_copyStored",
        "x-version-added": "12.5.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording to copy",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "destinationRecordingName",
            "in": "query",
            "description": "The destination name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoredRecording"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found"
          },
          "409": {
            "description": "A recording with the same name already exists on the system"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/live/{recordingName}": {
      "description": "A recording that is in progress",
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "get": {
        "summary": "List live recordings.",
        "operationId": "recordings_getLive",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveRecording"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      },
      "delete": {
        "summary": "Stop a live recording and discard it.",
        "operationId": "recordings_cancel",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/live/{recordingName}/stop": {
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "post": {
        "summary": "Stop a live recording and store it.",
        "operationId": "recordings_stop",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/live/{recordingName}/pause": {
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "post": {
        "summary": "Pause a live recording.",
        "operationId": "recordings_pause",
        "description": "Pausing a recording suspends silence detection, which will be restarted when the recording is unpaused. Paused time is not included in the accounting for maxDurationSeconds.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          },
          "409": {
            "description": "Recording not in session"
          }
        },
        "tags": [
          "recordings"
        ]
      },
      "delete": {
        "summary": "Unpause a live recording.",
        "operationId": "recordings_unpause",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          },
          "409": {
            "description": "Recording not in session"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/recordings/live/{recordingName}/mute": {
      "x-requires-modules": [
        "res_stasis_recording"
      ],
      "post": {
        "summary": "Mute a live recording.",
        "operationId": "recordings_mute",
        "description": "Muting a recording suspends silence detection, which will be restarted when the recording is unmuted.",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          },
          "409": {
            "description": "Recording not in session"
          }
        },
        "tags": [
          "recordings"
        ]
      },
      "delete": {
        "summary": "Unmute a live recording.",
        "operationId": "recordings_unmute",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "recordingName",
            "in": "path",
            "description": "The name of the recording",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Recording not found"
          },
          "409": {
            "description": "Recording not in session"
          }
        },
        "tags": [
          "recordings"
        ]
      }
    },
    "/sounds": {
      "description": "Sounds",
      "get": {
        "summary": "List all sounds.",
        "operationId": "sounds_list",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "lang",
            "in": "query",
            "description": "Lookup sound for a specific language.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Lookup sound in a specific format.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Sound"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "sounds"
        ]
      }
    },
    "/sounds/{soundId}": {
      "description": "Individual sound",
      "get": {
        "summary": "Get a sound's details.",
        "operationId": "sounds_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "soundId",
            "in": "path",
            "description": "Sound's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Sound"
                }
              }
            }
          }
        },
        "tags": [
          "sounds"
        ]
      }
    },
    "/playbacks/{playbackId}": {
      "description": "Control object for a playback operation.",
      "x-requires-modules": [
        "res_stasis_playback"
      ],
      "get": {
        "summary": "Get a playback's details.",
        "operationId": "playbacks_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "playbackId",
            "in": "path",
            "description": "Playback's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playback"
                }
              }
            }
          },
          "404": {
            "description": "The playback cannot be found"
          }
        },
        "tags": [
          "playbacks"
        ]
      },
      "delete": {
        "summary": "Stop a playback.",
        "operationId": "playbacks_stop",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "playbackId",
            "in": "path",
            "description": "Playback's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "The playback cannot be found"
          }
        },
        "tags": [
          "playbacks"
        ]
      }
    },
    "/playbacks/{playbackId}/control": {
      "description": "Control object for a playback operation.",
      "x-requires-modules": [
        "res_stasis_playback"
      ],
      "post": {
        "summary": "Control a playback.",
        "operationId": "playbacks_control",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "playbackId",
            "in": "path",
            "description": "Playback's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "operation",
            "in": "query",
            "description": "Operation to perform on the playback.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "restart",
                "pause",
                "unpause",
                "reverse",
                "forward"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "The provided operation parameter was invalid"
          },
          "404": {
            "description": "The playback cannot be found"
          },
          "409": {
            "description": "The operation cannot be performed in the playback's current state"
          }
        },
        "tags": [
          "playbacks"
        ]
      }
    },
    "/deviceStates": {
      "description": "Device states",
      "x-requires-modules": [
        "res_stasis_device_state"
      ],
      "get": {
        "summary": "List all ARI controlled device states.",
        "operationId": "deviceStates_list",
        "x-version-added": "12.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DeviceState"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "deviceStates"
        ]
      }
    },
    "/deviceStates/{deviceName}": {
      "description": "Device state",
      "x-requires-modules": [
        "res_stasis_device_state"
      ],
      "get": {
        "summary": "Retrieve the current state of a device.",
        "operationId": "deviceStates_get",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "deviceName",
            "in": "path",
            "description": "Name of the device",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceState"
                }
              }
            }
          }
        },
        "tags": [
          "deviceStates"
        ]
      },
      "put": {
        "summary": "Change the state of a device controlled by ARI. (Note - implicitly creates the device state).",
        "operationId": "deviceStates_update",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "deviceName",
            "in": "path",
            "description": "Name of the device",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deviceState",
            "in": "query",
            "description": "Device state value",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "NOT_INUSE",
                "INUSE",
                "BUSY",
                "INVALID",
                "UNAVAILABLE",
                "RINGING",
                "RINGINUSE",
                "ONHOLD"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Device name is missing"
          },
          "409": {
            "description": "Uncontrolled device specified"
          }
        },
        "tags": [
          "deviceStates"
        ]
      },
      "delete": {
        "summary": "Destroy a device-state controlled by ARI.",
        "operationId": "deviceStates_delete",
        "x-version-added": "12.0.0",
        "parameters": [
          {
            "name": "deviceName",
            "in": "path",
            "description": "Name of the device",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Device name is missing"
          },
          "409": {
            "description": "Uncontrolled device specified"
          }
        },
        "tags": [
          "deviceStates"
        ]
      }
    },
    "/mailboxes": {
      "description": "Mailboxes",
      "x-requires-modules": [
        "res_stasis_mailbox"
      ],
      "get": {
        "summary": "List all mailboxes.",
        "operationId": "mailboxes_list",
        "x-version-added": "12.1.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Mailbox"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "mailboxes"
        ]
      }
    },
    "/mailboxes/{mailboxName}": {
      "description": "Mailbox state",
      "x-requires-modules": [
        "res_stasis_mailbox"
      ],
      "get": {
        "summary": "Retrieve the current state of a mailbox.",
        "operationId": "mailboxes_get",
        "x-version-added": "12.1.0",
        "parameters": [
          {
            "name": "mailboxName",
            "in": "path",
            "description": "Name of the mailbox",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Mailbox"
                }
              }
            }
          },
          "404": {
            "description": "Mailbox not found"
          }
        },
        "tags": [
          "mailboxes"
        ]
      },
      "put": {
        "summary": "Change the state of a mailbox. (Note - implicitly creates the mailbox).",
        "operationId": "mailboxes_update",
        "x-version-added": "12.1.0",
        "parameters": [
          {
            "name": "mailboxName",
            "in": "path",
            "description": "Name of the mailbox",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "oldMessages",
            "in": "query",
            "description": "Count of old messages in the mailbox",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "newMessages",
            "in": "query",
            "description": "Count of new messages in the mailbox",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Mailbox not found"
          }
        },
        "tags": [
          "mailboxes"
        ]
      },
      "delete": {
        "summary": "Destroy a mailbox.",
        "operationId": "mailboxes_delete",
        "x-version-added": "12.1.0",
        "parameters": [
          {
            "name": "mailboxName",
            "in": "path",
            "description": "Name of the mailbox",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Mailbox not found"
          }
        },
        "tags": [
          "mailboxes"
        ]
      }
    },
    "/events": {
      "description": "Events from Asterisk to applications",
      "x-requires-modules": [
        "res_http_websocket"
      ],
      "get": {
        "summary": "WebSocket connection for events.",
        "operationId": "events_eventWebsocket",
        "x-version-added": "12.0.0",
        "x-upgrade": "websocket",
        "x-websocket-protocol": "ari",
        "parameters": [
          {
            "name": "app",
            "in": "query",
            "description": "Applications to subscribe to.",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "subscribeAll",
            "in": "query",
            "description": "Subscribe to all Asterisk events. If provided, the applications listed will be subscribed to all events, effectively disabling the application specific subscriptions. Default is 'false'.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Message"
                }
              }
            }
          }
        },
        "tags": [
          "events"
        ]
      }
    },
    "/events/user/{eventName}": {
      "description": "Stasis application user events",
      "x-requires-modules": [
        "res_http_websocket"
      ],
      "post": {
        "summary": "Generate a user event.",
        "operationId": "events_userEvent",
        "x-version-added": "12.3.0",
        "parameters": [
          {
            "name": "eventName",
            "in": "path",
            "description": "Event name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "application",
            "in": "query",
            "description": "The name of the application that will receive this event",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "source",
            "in": "query",
            "description": "URI for event source (channel:{channelId}, bridge:{bridgeId}, endpoint:{tech}/{resource}, deviceState:{deviceName}",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VariableBag"
              }
            }
          },
          "x-body-name": "variables",
          "x-param-insert-after": "source",
          "description": "The \"variables\" key in the body object holds custom key/value pairs to add to the user event. Ex. { \"variables\": { \"key\": \"value\" } }"
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Application does not exist."
          },
          "422": {
            "description": "Event source not found."
          },
          "400": {
            "description": "Invalid even tsource URI or userevent data."
          }
        },
        "tags": [
          "events"
        ]
      }
    },
    "/applications": {
      "description": "Stasis applications",
      "get": {
        "summary": "List all applications.",
        "operationId": "applications_list",
        "x-version-added": "13.0.0",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Application"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "applications"
        ]
      }
    },
    "/applications/{applicationName}": {
      "description": "Stasis application",
      "get": {
        "summary": "Get details of an application.",
        "operationId": "applications_get",
        "x-version-added": "13.0.0",
        "parameters": [
          {
            "name": "applicationName",
            "in": "path",
            "description": "Application's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Application"
                }
              }
            }
          },
          "404": {
            "description": "Application does not exist."
          }
        },
        "tags": [
          "applications"
        ]
      }
    },
    "/applications/{applicationName}/subscription": {
      "description": "Stasis application",
      "post": {
        "summary": "Subscribe an application to a event source.",
        "operationId": "applications_subscribe",
        "description": "Returns the state of the application after the subscriptions have changed",
        "x-version-added": "13.0.0",
        "parameters": [
          {
            "name": "applicationName",
            "in": "path",
            "description": "Application's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "eventSource",
            "in": "query",
            "description": "URI for event source (channel:{channelId}, bridge:{bridgeId}, endpoint:{tech}[/{resource}], deviceState:{deviceName}",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Application"
                }
              }
            }
          },
          "400": {
            "description": "Missing parameter."
          },
          "404": {
            "description": "Application does not exist."
          },
          "422": {
            "description": "Event source does not exist."
          }
        },
        "tags": [
          "applications"
        ]
      },
      "delete": {
        "summary": "Unsubscribe an application from an event source.",
        "operationId": "applications_unsubscribe",
        "description": "Returns the state of the application after the subscriptions have changed",
        "x-version-added": "13.0.0",
        "parameters": [
          {
            "name": "applicationName",
            "in": "path",
            "description": "Application's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "eventSource",
            "in": "query",
            "description": "URI for event source (channel:{channelId}, bridge:{bridgeId}, endpoint:{tech}[/{resource}], deviceState:{deviceName}",
            "required": true,
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Application"
                }
              }
            }
          },
          "400": {
            "description": "Missing parameter; event source scheme not recognized."
          },
          "404": {
            "description": "Application does not exist."
          },
          "409": {
            "description": "Application not subscribed to event source."
          },
          "422": {
            "description": "Event source does not exist."
          }
        },
        "tags": [
          "applications"
        ]
      }
    },
    "/applications/{applicationName}/eventFilter": {
      "description": "Stasis application",
      "put": {
        "summary": "Filter application events types.",
        "operationId": "applications_filter",
        "description": "Allowed and/or disallowed event type filtering can be done. The body (parameter) should specify a JSON key/value object that describes the type of event filtering needed. One, or both of the following keys can be designated:<br /><br />\"allowed\" - Specifies an allowed list of event types<br />\"disallowed\" - Specifies a disallowed list of event types<br /><br />Further, each of those key's value should be a JSON array that holds zero, or more JSON key/value objects. Each of these objects must contain the following key with an associated value:<br /><br />\"type\" - The type name of the event to filter<br /><br />The value must be the string name (case sensitive) of the event type that needs filtering. For example:<br /><br />{ \"allowed\": [ { \"type\": \"StasisStart\" }, { \"type\": \"StasisEnd\" } ] }<br /><br />As this specifies only an allowed list, then only those two event type messages are sent to the application. No other event messages are sent.<br /><br />The following rules apply:<br /><br />* If the body is empty, both the allowed and disallowed filters are set empty.<br />* If both list types are given then both are set to their respective values (note, specifying an empty array for a given type sets that type to empty).<br />* If only one list type is given then only that type is set. The other type is not updated.<br />* An empty \"allowed\" list means all events are allowed.<br />* An empty \"disallowed\" list means no events are disallowed.<br />* Disallowed events take precedence over allowed events if the event type is specified in both lists.",
        "x-version-added": "13.26.0",
        "parameters": [
          {
            "name": "applicationName",
            "in": "path",
            "description": "Application's name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true
              }
            }
          },
          "x-body-name": "filter",
          "x-param-insert-after": "applicationName",
          "description": "Specify which event types to allow/disallow"
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Application"
                }
              }
            }
          },
          "400": {
            "description": "Bad request."
          },
          "404": {
            "description": "Application does not exist."
          }
        },
        "tags": [
          "applications"
        ]
      }
    }
  },
  "components": {
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    },
    "schemas": {
      "AdditionalParam": {
        "type": "object",
        "description": "Protocol specific additional parameter",
        "properties": {
          "parameter_name": {
            "type": "string",
            "description": "Name of the parameter"
          },
          "parameter_value": {
            "type": "string",
            "description": "Value of the parameter"
          }
        },
        "required": [
          "parameter_name",
          "parameter_value"
        ],
        "x-source-api": "events"
      },
      "Application": {
        "type": "object",
        "description": "Details of a Stasis application",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of this application"
          },
          "channel_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Id's for channels subscribed to."
          },
          "bridge_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Id's for bridges subscribed to."
          },
          "endpoint_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "{tech}/{resource} for endpoints subscribed to."
          },
          "device_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Names of the devices subscribed to."
          },
          "events_allowed": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": true
            },
            "description": "Event types sent to the application."
          },
          "events_disallowed": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": true
            },
            "description": "Event types not sent to the application."
          }
        },
        "required": [
          "name",
          "channel_ids",
          "bridge_ids",
          "endpoint_ids",
          "device_names",
          "events_allowed",
          "events_disallowed"
        ],
        "x-source-api": "applications"
      },
      "ApplicationMoveFailed": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "destination": {
                "type": "string"
              },
              "args": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Arguments to the application"
              },
              "type": {
                "type": "string",
                "const": "ApplicationMoveFailed"
              }
            },
            "required": [
              "channel",
              "destination",
              "args"
            ]
          }
        ],
        "description": "Notification that trying to move a channel to another Stasis application failed.",
        "x-source-api": "events"
      },
      "ApplicationRegistered": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "ApplicationRegistered"
              }
            }
          }
        ],
        "description": "Notification that a Stasis app has been registered.",
        "x-source-api": "events"
      },
      "ApplicationReplaced": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "ApplicationReplaced"
              }
            }
          }
        ],
        "description": "Notification that another WebSocket has taken over for an application.\n\nAn application may only be subscribed to by a single WebSocket at a time. If multiple WebSockets attempt to subscribe to the same application, the newer WebSocket wins, and the older one receives this event.",
        "x-source-api": "events"
      },
      "ApplicationUnregistered": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "ApplicationUnregistered"
              }
            }
          }
        ],
        "description": "Notification that a Stasis app has been unregistered.",
        "x-source-api": "events"
      },
      "AsteriskInfo": {
        "type": "object",
        "description": "Asterisk system information",
        "properties": {
          "build": {
            "$ref": "#/components/schemas/BuildInfo",
            "description": "Info about how Asterisk was built"
          },
          "system": {
            "$ref": "#/components/schemas/SystemInfo",
            "description": "Info about the system running Asterisk"
          },
          "config": {
            "$ref": "#/components/schemas/ConfigInfo",
            "description": "Info about Asterisk configuration"
          },
          "status": {
            "$ref": "#/components/schemas/StatusInfo",
            "description": "Info about Asterisk status"
          }
        },
        "x-source-api": "asterisk"
      },
      "AsteriskPing": {
        "type": "object",
        "description": "Asterisk ping information",
        "properties": {
          "asterisk_id": {
            "type": "string",
            "description": "Asterisk id info"
          },
          "ping": {
            "type": "string",
            "description": "Always string value is pong"
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp string of request received time"
          }
        },
        "required": [
          "asterisk_id",
          "ping",
          "timestamp"
        ],
        "x-source-api": "asterisk"
      },
      "Bridge": {
        "type": "object",
        "description": "The merging of media from one or more channels.\n\nEveryone on the bridge receives the same audio.",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for this bridge"
          },
          "technology": {
            "type": "string",
            "description": "Name of the current bridging technology"
          },
          "bridge_type": {
            "type": "string",
            "description": "Type of bridge technology",
            "enum": [
              "mixing",
              "holding"
            ]
          },
          "bridge_class": {
            "type": "string",
            "description": "Bridging class"
          },
          "creator": {
            "type": "string",
            "description": "Entity that created the bridge"
          },
          "name": {
            "type": "string",
            "description": "Name the creator gave the bridge"
          },
          "channels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Ids of channels participating in this bridge"
          },
          "video_mode": {
            "type": "string",
            "description": "The video mode the bridge is using. One of 'none', 'talker', 'sfu', or 'single'."
          },
          "video_source_id": {
            "type": "string",
            "description": "The ID of the channel that is the source of video in this bridge, if one exists."
          },
          "creationtime": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when bridge was created"
          }
        },
        "required": [
          "id",
          "technology",
          "bridge_type",
          "bridge_class",
          "creator",
          "name",
          "channels",
          "creationtime"
        ],
        "x-source-api": "bridges"
      },
      "BridgeAttendedTransfer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "transferer_first_leg": {
                "$ref": "#/components/schemas/Channel",
                "description": "First leg of the transferer"
              },
              "transferer_second_leg": {
                "$ref": "#/components/schemas/Channel",
                "description": "Second leg of the transferer"
              },
              "replace_channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that is replacing transferer_first_leg in the swap"
              },
              "transferee": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that is being transferred"
              },
              "transfer_target": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that is being transferred to"
              },
              "result": {
                "type": "string",
                "description": "The result of the transfer attempt"
              },
              "is_external": {
                "type": "boolean",
                "description": "Whether the transfer was externally initiated or not"
              },
              "transferer_first_leg_bridge": {
                "$ref": "#/components/schemas/Bridge",
                "description": "Bridge the transferer first leg is in"
              },
              "transferer_second_leg_bridge": {
                "$ref": "#/components/schemas/Bridge",
                "description": "Bridge the transferer second leg is in"
              },
              "destination_type": {
                "type": "string",
                "description": "How the transfer was accomplished"
              },
              "destination_bridge": {
                "type": "string",
                "description": "Bridge that survived the merge result"
              },
              "destination_application": {
                "type": "string",
                "description": "Application that has been transferred into"
              },
              "destination_link_first_leg": {
                "$ref": "#/components/schemas/Channel",
                "description": "First leg of a link transfer result"
              },
              "destination_link_second_leg": {
                "$ref": "#/components/schemas/Channel",
                "description": "Second leg of a link transfer result"
              },
              "destination_threeway_channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "Transferer channel that survived the threeway result"
              },
              "destination_threeway_bridge": {
                "$ref": "#/components/schemas/Bridge",
                "description": "Bridge that survived the threeway result"
              },
              "type": {
                "type": "string",
                "const": "BridgeAttendedTransfer"
              }
            },
            "required": [
              "transferer_first_leg",
              "transferer_second_leg",
              "result",
              "is_external",
              "destination_type"
            ]
          }
        ],
        "description": "Notification that an attended transfer has occurred.",
        "x-source-api": "events"
      },
      "BridgeBlindTransfer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel performing the blind transfer"
              },
              "replace_channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that is replacing transferer when the transferee(s) can not be transferred directly"
              },
              "transferee": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that is being transferred"
              },
              "exten": {
                "type": "string",
                "description": "The extension transferred to"
              },
              "context": {
                "type": "string",
                "description": "The context transferred to"
              },
              "result": {
                "type": "string",
                "description": "The result of the transfer attempt"
              },
              "is_external": {
                "type": "boolean",
                "description": "Whether the transfer was externally initiated or not"
              },
              "bridge": {
                "$ref": "#/components/schemas/Bridge",
                "description": "The bridge being transferred"
              },
              "type": {
                "type": "string",
                "const": "BridgeBlindTransfer"
              }
            },
            "required": [
              "channel",
              "exten",
              "context",
              "result",
              "is_external"
            ]
          }
        ],
        "description": "Notification that a blind transfer has occurred.",
        "x-source-api": "events"
      },
      "BridgeCreated": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "type": {
                "type": "string",
                "const": "BridgeCreated"
              }
            },
            "required": [
              "bridge"
            ]
          }
        ],
        "description": "Notification that a bridge has been created.",
        "x-source-api": "events"
      },
      "BridgeDestroyed": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "type": {
                "type": "string",
                "const": "BridgeDestroyed"
              }
            },
            "required": [
              "bridge"
            ]
          }
        ],
        "description": "Notification that a bridge has been destroyed.",
        "x-source-api": "events"
      },
      "BridgeMerged": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "bridge_from": {
                "$ref": "#/components/schemas/Bridge"
              },
              "type": {
                "type": "string",
                "const": "BridgeMerged"
              }
            },
            "required": [
              "bridge",
              "bridge_from"
            ]
          }
        ],
        "description": "Notification that one bridge has merged into another.",
        "x-source-api": "events"
      },
      "BridgeVideoSourceChanged": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "old_video_source_id": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "const": "BridgeVideoSourceChanged"
              }
            },
            "required": [
              "bridge"
            ]
          }
        ],
        "description": "Notification that the source of video in a bridge has changed.",
        "x-source-api": "events"
      },
      "BuildInfo": {
        "type": "object",
        "description": "Info about how Asterisk was built",
        "properties": {
          "os": {
            "type": "string",
            "description": "OS Asterisk was built on."
          },
          "kernel": {
            "type": "string",
            "description": "Kernel version Asterisk was built on."
          },
          "options": {
            "type": "string",
            "description": "Compile time options, or empty string if default."
          },
          "machine": {
            "type": "string",
            "description": "Machine architecture (x86_64, i686, ppc, etc.)"
          },
          "date": {
            "type": "string",
            "description": "Date and time when Asterisk was built."
          },
          "user": {
            "type": "string",
            "description": "Username that build Asterisk"
          }
        },
        "required": [
          "os",
          "kernel",
          "options",
          "machine",
          "date",
          "user"
        ],
        "x-source-api": "asterisk"
      },
      "CallerID": {
        "type": "object",
        "description": "Caller identification",
        "properties": {
          "name": {
            "type": "string"
          },
          "number": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "number"
        ],
        "x-source-api": "channels"
      },
      "Channel": {
        "type": "object",
        "description": "A specific communication connection between Asterisk and an Endpoint.",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of the channel.\n\nThis is the same as the Uniqueid field in AMI."
          },
          "protocol_id": {
            "type": "string",
            "description": "Protocol id from underlying channel driver (i.e. Call-ID for chan_pjsip; will be empty if not applicable or not implemented by driver)."
          },
          "name": {
            "type": "string",
            "description": "Name of the channel (i.e. SIP/foo-0000a7e3)"
          },
          "state": {
            "type": "string",
            "enum": [
              "Down",
              "Rsrved",
              "OffHook",
              "Dialing",
              "Ring",
              "Ringing",
              "Up",
              "Busy",
              "Dialing Offhook",
              "Pre-ring",
              "Unknown"
            ]
          },
          "caller": {
            "$ref": "#/components/schemas/CallerID"
          },
          "connected": {
            "$ref": "#/components/schemas/CallerID"
          },
          "accountcode": {
            "type": "string"
          },
          "dialplan": {
            "$ref": "#/components/schemas/DialplanCEP",
            "description": "Current location in the dialplan"
          },
          "creationtime": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when channel was created"
          },
          "language": {
            "type": "string",
            "description": "The default spoken language"
          },
          "channelvars": {
            "type": "object",
            "additionalProperties": true,
            "description": "Channel variables"
          },
          "caller_rdnis": {
            "type": "string",
            "description": "The Caller ID RDNIS"
          },
          "tenantid": {
            "type": "string",
            "description": "The Tenant ID for the channel"
          }
        },
        "required": [
          "id",
          "protocol_id",
          "name",
          "state",
          "caller",
          "connected",
          "accountcode",
          "dialplan",
          "creationtime",
          "language"
        ],
        "x-source-api": "channels"
      },
      "ChannelCallerId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "caller_presentation": {
                "type": "integer",
                "description": "The integer representation of the Caller Presentation value."
              },
              "caller_presentation_txt": {
                "type": "string",
                "description": "The text representation of the Caller Presentation value."
              },
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that changed Caller ID."
              },
              "type": {
                "type": "string",
                "const": "ChannelCallerId"
              }
            },
            "required": [
              "caller_presentation",
              "caller_presentation_txt",
              "channel"
            ]
          }
        ],
        "description": "Channel changed Caller ID.",
        "x-source-api": "events"
      },
      "ChannelConnectedLine": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel whose connected line has changed."
              },
              "type": {
                "type": "string",
                "const": "ChannelConnectedLine"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Channel changed Connected Line.",
        "x-source-api": "events"
      },
      "ChannelCreated": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelCreated"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Notification that a channel has been created.",
        "x-source-api": "events"
      },
      "ChannelDestroyed": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "cause": {
                "type": "integer",
                "description": "Integer representation of the cause of the hangup"
              },
              "cause_txt": {
                "type": "string",
                "description": "Text representation of the cause of the hangup"
              },
              "tech_cause": {
                "type": "integer",
                "description": "Integer representation of the technology-specific off-nominal cause of the hangup."
              },
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelDestroyed"
              }
            },
            "required": [
              "cause",
              "cause_txt",
              "channel"
            ]
          }
        ],
        "description": "Notification that a channel has been destroyed.",
        "x-source-api": "events"
      },
      "ChannelDialplan": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that changed dialplan location."
              },
              "dialplan_app": {
                "type": "string",
                "description": "The application about to be executed."
              },
              "dialplan_app_data": {
                "type": "string",
                "description": "The data to be passed to the application."
              },
              "type": {
                "type": "string",
                "const": "ChannelDialplan"
              }
            },
            "required": [
              "channel",
              "dialplan_app",
              "dialplan_app_data"
            ]
          }
        ],
        "description": "Channel changed location in the dialplan.",
        "x-source-api": "events"
      },
      "ChannelDtmfReceived": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "digit": {
                "type": "string",
                "description": "DTMF digit received (0-9, A-E, # or *)"
              },
              "duration_ms": {
                "type": "integer",
                "description": "Number of milliseconds DTMF was received"
              },
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel on which DTMF was received"
              },
              "type": {
                "type": "string",
                "const": "ChannelDtmfReceived"
              }
            },
            "required": [
              "digit",
              "duration_ms",
              "channel"
            ]
          }
        ],
        "description": "DTMF received on a channel.\n\nThis event is sent when the DTMF ends. There is no notification about the start of DTMF",
        "x-source-api": "events"
      },
      "ChannelEnteredBridge": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelEnteredBridge"
              }
            },
            "required": [
              "bridge"
            ]
          }
        ],
        "description": "Notification that a channel has entered a bridge.",
        "x-source-api": "events"
      },
      "ChannelHangupRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "cause": {
                "type": "integer",
                "description": "Integer representation of the cause of the hangup."
              },
              "tech_cause": {
                "type": "integer",
                "description": "Integer representation of the technology-specific off-nominal cause of the hangup."
              },
              "soft": {
                "type": "boolean",
                "description": "Whether the hangup request was a soft hangup request."
              },
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel on which the hangup was requested."
              },
              "type": {
                "type": "string",
                "const": "ChannelHangupRequest"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "A hangup was requested on the channel.",
        "x-source-api": "events"
      },
      "ChannelHold": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that initiated the hold event."
              },
              "musicclass": {
                "type": "string",
                "description": "The music on hold class that the initiator requested."
              },
              "type": {
                "type": "string",
                "const": "ChannelHold"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "A channel initiated a media hold.",
        "x-source-api": "events"
      },
      "ChannelLeftBridge": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "bridge": {
                "$ref": "#/components/schemas/Bridge"
              },
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelLeftBridge"
              }
            },
            "required": [
              "bridge",
              "channel"
            ]
          }
        ],
        "description": "Notification that a channel has left a bridge.",
        "x-source-api": "events"
      },
      "ChannelStateChange": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelStateChange"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Notification of a channel's state change.",
        "x-source-api": "events"
      },
      "ChannelTalkingFinished": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel on which talking completed."
              },
              "duration": {
                "type": "integer",
                "description": "The length of time, in milliseconds, that talking was detected on the channel"
              },
              "type": {
                "type": "string",
                "const": "ChannelTalkingFinished"
              }
            },
            "required": [
              "channel",
              "duration"
            ]
          }
        ],
        "description": "Talking is no longer detected on the channel.",
        "x-source-api": "events"
      },
      "ChannelTalkingStarted": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel on which talking started."
              },
              "type": {
                "type": "string",
                "const": "ChannelTalkingStarted"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Talking was detected on the channel.",
        "x-source-api": "events"
      },
      "ChannelToneDetected": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel the tone was detected on."
              },
              "type": {
                "type": "string",
                "const": "ChannelToneDetected"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Tone was detected on the channel.",
        "x-source-api": "events"
      },
      "ChannelTransfer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "description": "Transfer State"
              },
              "refer_to": {
                "$ref": "#/components/schemas/ReferTo",
                "description": "Refer-To information with optionally both affected channels"
              },
              "referred_by": {
                "$ref": "#/components/schemas/ReferredBy",
                "description": "Referred-By SIP Header according rfc3892"
              },
              "type": {
                "type": "string",
                "const": "ChannelTransfer"
              }
            },
            "required": [
              "refer_to",
              "referred_by"
            ]
          }
        ],
        "description": "transfer on a channel.",
        "x-source-api": "events"
      },
      "ChannelUnhold": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel that initiated the unhold event."
              },
              "type": {
                "type": "string",
                "const": "ChannelUnhold"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "A channel initiated a media unhold.",
        "x-source-api": "events"
      },
      "ChannelUserevent": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "eventname": {
                "type": "string",
                "description": "The name of the user event."
              },
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "A channel that is signaled with the user event."
              },
              "bridge": {
                "$ref": "#/components/schemas/Bridge",
                "description": "A bridge that is signaled with the user event."
              },
              "endpoint": {
                "$ref": "#/components/schemas/Endpoint",
                "description": "A endpoint that is signaled with the user event."
              },
              "userevent": {
                "type": "object",
                "additionalProperties": true,
                "description": "Custom Userevent data"
              },
              "type": {
                "type": "string",
                "const": "ChannelUserevent"
              }
            },
            "required": [
              "eventname",
              "userevent"
            ]
          }
        ],
        "description": "User-generated event with additional user-defined fields in the object.",
        "x-source-api": "events"
      },
      "ChannelVarset": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "variable": {
                "type": "string",
                "description": "The variable that changed."
              },
              "value": {
                "type": "string",
                "description": "The new value of the variable."
              },
              "channel": {
                "$ref": "#/components/schemas/Channel",
                "description": "The channel on which the variable was set.\n\nIf missing, the variable is a global variable."
              },
              "type": {
                "type": "string",
                "const": "ChannelVarset"
              }
            },
            "required": [
              "variable",
              "value"
            ]
          }
        ],
        "description": "Channel variable changed.",
        "x-source-api": "events"
      },
      "ConfigInfo": {
        "type": "object",
        "description": "Info about Asterisk configuration",
        "properties": {
          "name": {
            "type": "string",
            "description": "Asterisk system name."
          },
          "default_language": {
            "type": "string",
            "description": "Default language for media playback."
          },
          "max_channels": {
            "type": "integer",
            "description": "Maximum number of simultaneous channels."
          },
          "max_open_files": {
            "type": "integer",
            "description": "Maximum number of open file handles (files, sockets)."
          },
          "max_load": {
            "type": "number",
            "format": "double",
            "description": "Maximum load avg on system."
          },
          "setid": {
            "$ref": "#/components/schemas/SetId",
            "description": "Effective user/group id for running Asterisk."
          }
        },
        "required": [
          "name",
          "default_language",
          "setid"
        ],
        "x-source-api": "asterisk"
      },
      "ConfigTuple": {
        "type": "object",
        "description": "A key/value pair that makes up part of a configuration object.",
        "properties": {
          "attribute": {
            "type": "string",
            "description": "A configuration object attribute."
          },
          "value": {
            "type": "string",
            "description": "The value for the attribute."
          }
        },
        "required": [
          "attribute",
          "value"
        ],
        "x-source-api": "asterisk"
      },
      "ContactInfo": {
        "type": "object",
        "description": "Detailed information about a contact on an endpoint.",
        "properties": {
          "uri": {
            "type": "string",
            "description": "The location of the contact."
          },
          "contact_status": {
            "type": "string",
            "description": "The current status of the contact.",
            "enum": [
              "Unreachable",
              "Reachable",
              "Unknown",
              "NonQualified",
              "Removed"
            ]
          },
          "aor": {
            "type": "string",
            "description": "The Address of Record this contact belongs to."
          },
          "roundtrip_usec": {
            "type": "string",
            "description": "Current round trip time, in microseconds, for the contact."
          }
        },
        "required": [
          "uri",
          "contact_status",
          "aor"
        ],
        "x-source-api": "events"
      },
      "ContactStatusChange": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "endpoint": {
                "$ref": "#/components/schemas/Endpoint"
              },
              "contact_info": {
                "$ref": "#/components/schemas/ContactInfo"
              },
              "type": {
                "type": "string",
                "const": "ContactStatusChange"
              }
            },
            "required": [
              "endpoint",
              "contact_info"
            ]
          }
        ],
        "description": "The state of a contact on an endpoint has changed.",
        "x-source-api": "events"
      },
      "DeviceState": {
        "type": "object",
        "description": "Represents the state of a device.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the device."
          },
          "state": {
            "type": "string",
            "description": "Device's state",
            "enum": [
              "UNKNOWN",
              "NOT_INUSE",
              "INUSE",
              "BUSY",
              "INVALID",
              "UNAVAILABLE",
              "RINGING",
              "RINGINUSE",
              "ONHOLD"
            ]
          }
        },
        "required": [
          "name",
          "state"
        ],
        "x-source-api": "deviceStates"
      },
      "DeviceStateChanged": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "device_state": {
                "$ref": "#/components/schemas/DeviceState",
                "description": "Device state object"
              },
              "type": {
                "type": "string",
                "const": "DeviceStateChanged"
              }
            },
            "required": [
              "device_state"
            ]
          }
        ],
        "description": "Notification that a device state has changed.",
        "x-source-api": "events"
      },
      "Dial": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "caller": {
                "$ref": "#/components/schemas/Channel",
                "description": "The calling channel."
              },
              "peer": {
                "$ref": "#/components/schemas/Channel",
                "description": "The dialed channel."
              },
              "forward": {
                "type": "string",
                "description": "Forwarding target requested by the original dialed channel."
              },
              "forwarded": {
                "$ref": "#/components/schemas/Channel",
                "description": "Channel that the caller has been forwarded to."
              },
              "dialstring": {
                "type": "string",
                "description": "The dial string for calling the peer channel."
              },
              "dialstatus": {
                "type": "string",
                "description": "Current status of the dialing attempt to the peer."
              },
              "type": {
                "type": "string",
                "const": "Dial"
              }
            },
            "required": [
              "peer",
              "dialstatus"
            ]
          }
        ],
        "description": "Dialing state has changed.",
        "x-source-api": "events"
      },
      "Dialed": {
        "type": "object",
        "description": "Dialed channel information.",
        "x-source-api": "channels"
      },
      "DialplanCEP": {
        "type": "object",
        "description": "Dialplan location (context/extension/priority)",
        "properties": {
          "context": {
            "type": "string",
            "description": "Context in the dialplan"
          },
          "exten": {
            "type": "string",
            "description": "Extension in the dialplan"
          },
          "priority": {
            "type": "integer",
            "format": "int64",
            "description": "Priority in the dialplan"
          },
          "app_name": {
            "type": "string",
            "description": "Name of current dialplan application"
          },
          "app_data": {
            "type": "string",
            "description": "Parameter of current dialplan application"
          }
        },
        "required": [
          "context",
          "exten",
          "priority",
          "app_name",
          "app_data"
        ],
        "x-source-api": "channels"
      },
      "Endpoint": {
        "type": "object",
        "description": "An external device that may offer/accept calls to/from Asterisk.\n\nUnlike most resources, which have a single unique identifier, an endpoint is uniquely identified by the technology/resource pair.",
        "properties": {
          "technology": {
            "type": "string",
            "description": "Technology of the endpoint"
          },
          "resource": {
            "type": "string",
            "description": "Identifier of the endpoint, specific to the given technology."
          },
          "state": {
            "type": "string",
            "description": "Endpoint's state",
            "enum": [
              "unknown",
              "offline",
              "online"
            ]
          },
          "channel_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Id's of channels associated with this endpoint"
          }
        },
        "required": [
          "technology",
          "resource",
          "channel_ids"
        ],
        "x-source-api": "endpoints"
      },
      "EndpointStateChange": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "endpoint": {
                "$ref": "#/components/schemas/Endpoint"
              },
              "type": {
                "type": "string",
                "const": "EndpointStateChange"
              }
            },
            "required": [
              "endpoint"
            ]
          }
        ],
        "description": "Endpoint state changed.",
        "x-source-api": "events"
      },
      "Event": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Message"
          },
          {
            "type": "object",
            "properties": {
              "application": {
                "type": "string",
                "description": "Name of the application receiving the event."
              },
              "timestamp": {
                "type": "string",
                "format": "date-time",
                "description": "Time at which this event was created."
              },
              "type": {
                "type": "string",
                "enum": [
                  "DeviceStateChanged",
                  "PlaybackStarted",
                  "PlaybackContinuing",
                  "PlaybackFinished",
                  "RecordingStarted",
                  "RecordingFinished",
                  "RecordingFailed",
                  "ApplicationMoveFailed",
                  "ApplicationRegistered",
                  "ApplicationUnregistered",
                  "ApplicationReplaced",
                  "BridgeCreated",
                  "BridgeDestroyed",
                  "BridgeMerged",
                  "BridgeBlindTransfer",
                  "BridgeAttendedTransfer",
                  "BridgeVideoSourceChanged",
                  "ChannelCreated",
                  "ChannelDestroyed",
                  "ChannelEnteredBridge",
                  "ChannelLeftBridge",
                  "ChannelStateChange",
                  "ChannelDtmfReceived",
                  "ChannelDialplan",
                  "ChannelCallerId",
                  "ChannelUserevent",
                  "ChannelHangupRequest",
                  "ChannelVarset",
                  "ChannelToneDetected",
                  "ChannelTalkingStarted",
                  "ChannelTalkingFinished",
                  "ChannelHold",
                  "ChannelUnhold",
                  "ContactStatusChange",
                  "EndpointStateChange",
                  "Dial",
                  "StasisEnd",
                  "StasisStart",
                  "TextMessageReceived",
                  "ChannelConnectedLine",
                  "PeerStatusChange",
                  "ChannelTransfer",
                  "RESTResponse"
                ]
              }
            },
            "required": [
              "application",
              "timestamp"
            ],
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "DeviceStateChanged": "#/components/schemas/DeviceStateChanged",
                "PlaybackStarted": "#/components/schemas/PlaybackStarted",
                "PlaybackContinuing": "#/components/schemas/PlaybackContinuing",
                "PlaybackFinished": "#/components/schemas/PlaybackFinished",
                "RecordingStarted": "#/components/schemas/RecordingStarted",
                "RecordingFinished": "#/components/schemas/RecordingFinished",
                "RecordingFailed": "#/components/schemas/RecordingFailed",
                "ApplicationMoveFailed": "#/components/schemas/ApplicationMoveFailed",
                "ApplicationRegistered": "#/components/schemas/ApplicationRegistered",
                "ApplicationUnregistered": "#/components/schemas/ApplicationUnregistered",
                "ApplicationReplaced": "#/components/schemas/ApplicationReplaced",
                "BridgeCreated": "#/components/schemas/BridgeCreated",
                "BridgeDestroyed": "#/components/schemas/BridgeDestroyed",
                "BridgeMerged": "#/components/schemas/BridgeMerged",
                "BridgeBlindTransfer": "#/components/schemas/BridgeBlindTransfer",
                "BridgeAttendedTransfer": "#/components/schemas/BridgeAttendedTransfer",
                "BridgeVideoSourceChanged": "#/components/schemas/BridgeVideoSourceChanged",
                "ChannelCreated": "#/components/schemas/ChannelCreated",
                "ChannelDestroyed": "#/components/schemas/ChannelDestroyed",
                "ChannelEnteredBridge": "#/components/schemas/ChannelEnteredBridge",
                "ChannelLeftBridge": "#/components/schemas/ChannelLeftBridge",
                "ChannelStateChange": "#/components/schemas/ChannelStateChange",
                "ChannelDtmfReceived": "#/components/schemas/ChannelDtmfReceived",
                "ChannelDialplan": "#/components/schemas/ChannelDialplan",
                "ChannelCallerId": "#/components/schemas/ChannelCallerId",
                "ChannelUserevent": "#/components/schemas/ChannelUserevent",
                "ChannelHangupRequest": "#/components/schemas/ChannelHangupRequest",
                "ChannelVarset": "#/components/schemas/ChannelVarset",
                "ChannelToneDetected": "#/components/schemas/ChannelToneDetected",
                "ChannelTalkingStarted": "#/components/schemas/ChannelTalkingStarted",
                "ChannelTalkingFinished": "#/components/schemas/ChannelTalkingFinished",
                "ChannelHold": "#/components/schemas/ChannelHold",
                "ChannelUnhold": "#/components/schemas/ChannelUnhold",
                "ContactStatusChange": "#/components/schemas/ContactStatusChange",
                "EndpointStateChange": "#/components/schemas/EndpointStateChange",
                "Dial": "#/components/schemas/Dial",
                "StasisEnd": "#/components/schemas/StasisEnd",
                "StasisStart": "#/components/schemas/StasisStart",
                "TextMessageReceived": "#/components/schemas/TextMessageReceived",
                "ChannelConnectedLine": "#/components/schemas/ChannelConnectedLine",
                "PeerStatusChange": "#/components/schemas/PeerStatusChange",
                "ChannelTransfer": "#/components/schemas/ChannelTransfer",
                "RESTResponse": "#/components/schemas/RESTResponse"
              }
            }
          }
        ],
        "description": "Base type for asynchronous events from Asterisk.",
        "x-source-api": "events"
      },
      "FormatLangPair": {
        "type": "object",
        "description": "Identifies the format and language of a sound file",
        "properties": {
          "language": {
            "type": "string"
          },
          "format": {
            "type": "string"
          }
        },
        "required": [
          "language",
          "format"
        ],
        "x-source-api": "sounds"
      },
      "LiveRecording": {
        "type": "object",
        "description": "A recording that is in progress",
        "properties": {
          "name": {
            "type": "string",
            "description": "Base name for the recording"
          },
          "format": {
            "type": "string",
            "description": "Recording format (wav, gsm, etc.)"
          },
          "target_uri": {
            "type": "string",
            "description": "URI for the channel or bridge being recorded"
          },
          "state": {
            "type": "string",
            "enum": [
              "queued",
              "recording",
              "paused",
              "done",
              "failed",
              "canceled"
            ]
          },
          "duration": {
            "type": "integer",
            "description": "Duration in seconds of the recording"
          },
          "talking_duration": {
            "type": "integer",
            "description": "Duration of talking, in seconds, detected in the recording. This is only available if the recording was initiated with a non-zero maxSilenceSeconds."
          },
          "silence_duration": {
            "type": "integer",
            "description": "Duration of silence, in seconds, detected in the recording. This is only available if the recording was initiated with a non-zero maxSilenceSeconds."
          },
          "cause": {
            "type": "string",
            "description": "Cause for recording failure if failed"
          }
        },
        "required": [
          "name",
          "format",
          "target_uri",
          "state"
        ],
        "x-source-api": "recordings"
      },
      "LogChannel": {
        "type": "object",
        "description": "Details of an Asterisk log channel",
        "properties": {
          "channel": {
            "type": "string",
            "description": "The log channel path"
          },
          "type": {
            "type": "string",
            "description": "Types of logs for the log channel"
          },
          "status": {
            "type": "string",
            "description": "Whether or not a log type is enabled"
          },
          "configuration": {
            "type": "string",
            "description": "The various log levels"
          }
        },
        "required": [
          "channel",
          "type",
          "status",
          "configuration"
        ],
        "x-source-api": "asterisk"
      },
      "Mailbox": {
        "type": "object",
        "description": "Represents the state of a mailbox.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the mailbox."
          },
          "old_messages": {
            "type": "integer",
            "description": "Count of old messages in the mailbox."
          },
          "new_messages": {
            "type": "integer",
            "description": "Count of new messages in the mailbox."
          }
        },
        "required": [
          "name",
          "old_messages",
          "new_messages"
        ],
        "x-source-api": "mailboxes"
      },
      "Message": {
        "type": "object",
        "description": "Base type for errors and events",
        "properties": {
          "type": {
            "type": "string",
            "description": "Indicates the type of this message.",
            "enum": [
              "MissingParams",
              "Event"
            ]
          },
          "asterisk_id": {
            "type": "string",
            "description": "The unique ID for the Asterisk instance that raised this event."
          }
        },
        "required": [
          "type"
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "MissingParams": "#/components/schemas/MissingParams",
            "Event": "#/components/schemas/Event"
          }
        },
        "x-source-api": "events"
      },
      "MissingParams": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Message"
          },
          {
            "type": "object",
            "properties": {
              "params": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "A list of the missing parameters"
              },
              "type": {
                "type": "string",
                "const": "MissingParams"
              }
            },
            "required": [
              "params"
            ]
          }
        ],
        "description": "Error event sent when required params are missing.",
        "x-source-api": "events"
      },
      "Module": {
        "type": "object",
        "description": "Details of an Asterisk module",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of this module"
          },
          "description": {
            "type": "string",
            "description": "The description of this module"
          },
          "use_count": {
            "type": "integer",
            "description": "The number of times this module is being used"
          },
          "status": {
            "type": "string",
            "description": "The running status of this module"
          },
          "support_level": {
            "type": "string",
            "description": "The support state of this module"
          }
        },
        "required": [
          "name",
          "description",
          "use_count",
          "status",
          "support_level"
        ],
        "x-source-api": "asterisk"
      },
      "Peer": {
        "type": "object",
        "description": "Detailed information about a remote peer that communicates with Asterisk.",
        "properties": {
          "peer_status": {
            "type": "string",
            "description": "The current state of the peer. Note that the values of the status are dependent on the underlying peer technology."
          },
          "cause": {
            "type": "string",
            "description": "An optional reason associated with the change in peer_status."
          },
          "address": {
            "type": "string",
            "description": "The IP address of the peer."
          },
          "port": {
            "type": "string",
            "description": "The port of the peer."
          },
          "time": {
            "type": "string",
            "description": "The last known time the peer was contacted."
          }
        },
        "required": [
          "peer_status"
        ],
        "x-source-api": "events"
      },
      "PeerStatusChange": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "endpoint": {
                "$ref": "#/components/schemas/Endpoint"
              },
              "peer": {
                "$ref": "#/components/schemas/Peer"
              },
              "type": {
                "type": "string",
                "const": "PeerStatusChange"
              }
            },
            "required": [
              "endpoint",
              "peer"
            ]
          }
        ],
        "description": "The state of a peer associated with an endpoint has changed.",
        "x-source-api": "events"
      },
      "Playback": {
        "type": "object",
        "description": "Object representing the playback of media to a channel",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID for this playback operation"
          },
          "media_uri": {
            "type": "string",
            "description": "The URI for the media currently being played back."
          },
          "next_media_uri": {
            "type": "string",
            "description": "If a list of URIs is being played, the next media URI to be played back."
          },
          "target_uri": {
            "type": "string",
            "description": "URI for the channel or bridge to play the media on"
          },
          "language": {
            "type": "string",
            "description": "For media types that support multiple languages, the language requested for playback."
          },
          "state": {
            "type": "string",
            "description": "Current state of the playback operation.",
            "enum": [
              "queued",
              "playing",
              "continuing",
              "done",
              "failed"
            ]
          }
        },
        "required": [
          "id",
          "media_uri",
          "target_uri",
          "state"
        ],
        "x-source-api": "playbacks"
      },
      "PlaybackContinuing": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "playback": {
                "$ref": "#/components/schemas/Playback",
                "description": "Playback control object"
              },
              "type": {
                "type": "string",
                "const": "PlaybackContinuing"
              }
            },
            "required": [
              "playback"
            ]
          }
        ],
        "description": "Event showing the continuation of a media playback operation from one media URI to the next in the list.",
        "x-source-api": "events"
      },
      "PlaybackFinished": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "playback": {
                "$ref": "#/components/schemas/Playback",
                "description": "Playback control object"
              },
              "type": {
                "type": "string",
                "const": "PlaybackFinished"
              }
            },
            "required": [
              "playback"
            ]
          }
        ],
        "description": "Event showing the completion of a media playback operation.",
        "x-source-api": "events"
      },
      "PlaybackStarted": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "playback": {
                "$ref": "#/components/schemas/Playback",
                "description": "Playback control object"
              },
              "type": {
                "type": "string",
                "const": "PlaybackStarted"
              }
            },
            "required": [
              "playback"
            ]
          }
        ],
        "description": "Event showing the start of a media playback operation.",
        "x-source-api": "events"
      },
      "RESTHeader": {
        "type": "object",
        "description": "REST over Websocket header",
        "properties": {
          "name": {
            "type": "string",
            "description": "Header name"
          },
          "value": {
            "type": "string",
            "description": "Header value"
          }
        },
        "required": [
          "name",
          "value"
        ],
        "x-source-api": "events"
      },
      "RESTQueryStringParameter": {
        "type": "object",
        "description": "REST over Websocket Query String Parameter",
        "properties": {
          "name": {
            "type": "string",
            "description": "Parameter name"
          },
          "value": {
            "type": "string",
            "description": "Parameter value"
          }
        },
        "required": [
          "name",
          "value"
        ],
        "x-source-api": "events"
      },
      "RESTRequest": {
        "type": "object",
        "description": "REST over Websocket Request.",
        "properties": {
          "type": {
            "type": "string",
            "description": "Message type.  Must be 'RESTRequest'"
          },
          "transaction_id": {
            "type": "string",
            "description": "Opaque transaction id.  Can be any valid string.  Will be returned in any response to this request."
          },
          "request_id": {
            "type": "string",
            "description": "Opaque request id.  Can be any valid string.  Will be returned in any response to this request."
          },
          "method": {
            "type": "string",
            "description": "HTTP method (GET, PUT, POST, DELETE, etc.)"
          },
          "uri": {
            "type": "string",
            "description": "Resource URI with optional query string parameters."
          },
          "content_type": {
            "type": "string",
            "description": "The Content-Type of the message body."
          },
          "query_strings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RESTQueryStringParameter"
            },
            "description": "Request query string parameters."
          },
          "message_body": {
            "type": "string",
            "description": "Request message body. Only content types application/json and application/x-www-form-urlencoded are supported."
          }
        },
        "required": [
          "type",
          "transaction_id",
          "request_id",
          "method",
          "uri"
        ],
        "x-source-api": "events"
      },
      "RESTResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "transaction_id": {
                "type": "string",
                "description": "Opaque transaction id.  Will be whatever was specified on the original request."
              },
              "request_id": {
                "type": "string",
                "description": "Opaque request id.  Will be whatever was specified on the original request."
              },
              "status_code": {
                "type": "integer",
                "description": "HTTP status code"
              },
              "reason_phrase": {
                "type": "string",
                "description": "HTTP reason phrase"
              },
              "uri": {
                "type": "string",
                "description": "Original request resource URI"
              },
              "content_type": {
                "type": "string",
                "description": "The Content-Type of the message body."
              },
              "message_body": {
                "type": "string",
                "description": "Response message body"
              },
              "type": {
                "type": "string",
                "const": "RESTResponse"
              }
            },
            "required": [
              "transaction_id",
              "request_id",
              "status_code",
              "reason_phrase",
              "uri"
            ]
          }
        ],
        "description": "REST over Websocket Response.",
        "x-source-api": "events"
      },
      "RTPstat": {
        "type": "object",
        "description": "A statistics of a RTP.",
        "properties": {
          "txcount": {
            "type": "integer",
            "description": "Number of packets transmitted."
          },
          "rxcount": {
            "type": "integer",
            "description": "Number of packets received."
          },
          "txjitter": {
            "type": "number",
            "format": "double",
            "description": "Jitter on transmitted packets."
          },
          "rxjitter": {
            "type": "number",
            "format": "double",
            "description": "Jitter on received packets."
          },
          "remote_maxjitter": {
            "type": "number",
            "format": "double",
            "description": "Maximum jitter on remote side."
          },
          "remote_minjitter": {
            "type": "number",
            "format": "double",
            "description": "Minimum jitter on remote side."
          },
          "remote_normdevjitter": {
            "type": "number",
            "format": "double",
            "description": "Average jitter on remote side."
          },
          "remote_stdevjitter": {
            "type": "number",
            "format": "double",
            "description": "Standard deviation jitter on remote side."
          },
          "local_maxjitter": {
            "type": "number",
            "format": "double",
            "description": "Maximum jitter on local side."
          },
          "local_minjitter": {
            "type": "number",
            "format": "double",
            "description": "Minimum jitter on local side."
          },
          "local_normdevjitter": {
            "type": "number",
            "format": "double",
            "description": "Average jitter on local side."
          },
          "local_stdevjitter": {
            "type": "number",
            "format": "double",
            "description": "Standard deviation jitter on local side."
          },
          "txploss": {
            "type": "integer",
            "description": "Number of transmitted packets lost."
          },
          "rxploss": {
            "type": "integer",
            "description": "Number of received packets lost."
          },
          "remote_maxrxploss": {
            "type": "number",
            "format": "double",
            "description": "Maximum number of packets lost on remote side."
          },
          "remote_minrxploss": {
            "type": "number",
            "format": "double",
            "description": "Minimum number of packets lost on remote side."
          },
          "remote_normdevrxploss": {
            "type": "number",
            "format": "double",
            "description": "Average number of packets lost on remote side."
          },
          "remote_stdevrxploss": {
            "type": "number",
            "format": "double",
            "description": "Standard deviation packets lost on remote side."
          },
          "local_maxrxploss": {
            "type": "number",
            "format": "double",
            "description": "Maximum number of packets lost on local side."
          },
          "local_minrxploss": {
            "type": "number",
            "format": "double",
            "description": "Minimum number of packets lost on local side."
          },
          "local_normdevrxploss": {
            "type": "number",
            "format": "double",
            "description": "Average number of packets lost on local side."
          },
          "local_stdevrxploss": {
            "type": "number",
            "format": "double",
            "description": "Standard deviation packets lost on local side."
          },
          "rtt": {
            "type": "number",
            "format": "double",
            "description": "Total round trip time."
          },
          "maxrtt": {
            "type": "number",
            "format": "double",
            "description": "Maximum round trip time."
          },
          "minrtt": {
            "type": "number",
            "format": "double",
            "description": "Minimum round trip time."
          },
          "normdevrtt": {
            "type": "number",
            "format": "double",
            "description": "Average round trip time."
          },
          "stdevrtt": {
            "type": "number",
            "format": "double",
            "description": "Standard deviation round trip time."
          },
          "local_ssrc": {
            "type": "integer",
            "description": "Our SSRC."
          },
          "remote_ssrc": {
            "type": "integer",
            "description": "Their SSRC."
          },
          "txoctetcount": {
            "type": "integer",
            "description": "Number of octets transmitted."
          },
          "rxoctetcount": {
            "type": "integer",
            "description": "Number of octets received."
          },
          "channel_uniqueid": {
            "type": "string",
            "description": "The Asterisk channel's unique ID that owns this instance."
          }
        },
        "required": [
          "txcount",
          "rxcount",
          "txploss",
          "rxploss",
          "local_ssrc",
          "remote_ssrc",
          "txoctetcount",
          "rxoctetcount",
          "channel_uniqueid"
        ],
        "x-source-api": "channels"
      },
      "RecordingFailed": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "recording": {
                "$ref": "#/components/schemas/LiveRecording",
                "description": "Recording control object"
              },
              "type": {
                "type": "string",
                "const": "RecordingFailed"
              }
            },
            "required": [
              "recording"
            ]
          }
        ],
        "description": "Event showing failure of a recording operation.",
        "x-source-api": "events"
      },
      "RecordingFinished": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "recording": {
                "$ref": "#/components/schemas/LiveRecording",
                "description": "Recording control object"
              },
              "type": {
                "type": "string",
                "const": "RecordingFinished"
              }
            },
            "required": [
              "recording"
            ]
          }
        ],
        "description": "Event showing the completion of a recording operation.",
        "x-source-api": "events"
      },
      "RecordingStarted": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "recording": {
                "$ref": "#/components/schemas/LiveRecording",
                "description": "Recording control object"
              },
              "type": {
                "type": "string",
                "const": "RecordingStarted"
              }
            },
            "required": [
              "recording"
            ]
          }
        ],
        "description": "Event showing the start of a recording operation.",
        "x-source-api": "events"
      },
      "ReferTo": {
        "type": "object",
        "description": "transfer destination requested by transferee",
        "properties": {
          "requested_destination": {
            "$ref": "#/components/schemas/RequiredDestination"
          },
          "destination_channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "The Channel Object, that is to be replaced"
          },
          "connected_channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "Channel, connected to the to be replaced channel"
          },
          "bridge": {
            "$ref": "#/components/schemas/Bridge",
            "description": "Bridge connecting both destination channels"
          }
        },
        "required": [
          "requested_destination"
        ],
        "x-source-api": "events"
      },
      "ReferredBy": {
        "type": "object",
        "description": "transfer destination requested by transferee",
        "properties": {
          "source_channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "The channel on which the refer was received"
          },
          "connected_channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "Channel, Connected to the channel, receiving the transfer request on."
          },
          "bridge": {
            "$ref": "#/components/schemas/Bridge",
            "description": "Bridge connecting both Channels"
          }
        },
        "required": [
          "source_channel"
        ],
        "x-source-api": "events"
      },
      "RequiredDestination": {
        "type": "object",
        "description": "Information about the requested destination",
        "properties": {
          "protocol_id": {
            "type": "string",
            "description": "the requested protocol-id by the referee in case of SIP channel, this is a SIP Call ID, Mutually exclusive to destination"
          },
          "destination": {
            "type": "string",
            "description": "Destination User Part. Only for Blind transfer. Mutually exclusive to protocol_id"
          },
          "additional_protocol_params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdditionalParam"
            },
            "description": "List of additional protocol specific information"
          }
        },
        "x-source-api": "events"
      },
      "SetId": {
        "type": "object",
        "description": "Effective user/group id",
        "properties": {
          "user": {
            "type": "string",
            "description": "Effective user id."
          },
          "group": {
            "type": "string",
            "description": "Effective group id."
          }
        },
        "required": [
          "user",
          "group"
        ],
        "x-source-api": "asterisk"
      },
      "Sound": {
        "type": "object",
        "description": "A media file that may be played back.",
        "properties": {
          "id": {
            "type": "string",
            "description": "Sound's identifier."
          },
          "text": {
            "type": "string",
            "description": "Text description of the sound, usually the words spoken."
          },
          "formats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormatLangPair"
            },
            "description": "The formats and languages in which this sound is available."
          }
        },
        "required": [
          "id",
          "formats"
        ],
        "x-source-api": "sounds"
      },
      "StasisEnd": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "StasisEnd"
              }
            },
            "required": [
              "channel"
            ]
          }
        ],
        "description": "Notification that a channel has left a Stasis application.",
        "x-source-api": "events"
      },
      "StasisStart": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "args": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Arguments to the application"
              },
              "channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "replace_channel": {
                "$ref": "#/components/schemas/Channel"
              },
              "type": {
                "type": "string",
                "const": "StasisStart"
              }
            },
            "required": [
              "args",
              "channel"
            ]
          }
        ],
        "description": "Notification that a channel has entered a Stasis application.",
        "x-source-api": "events"
      },
      "StatusInfo": {
        "type": "object",
        "description": "Info about Asterisk status",
        "properties": {
          "startup_time": {
            "type": "string",
            "format": "date-time",
            "description": "Time when Asterisk was started."
          },
          "last_reload_time": {
            "type": "string",
            "format": "date-time",
            "description": "Time when Asterisk was last reloaded."
          }
        },
        "required": [
          "startup_time",
          "last_reload_time"
        ],
        "x-source-api": "asterisk"
      },
      "StoredRecording": {
        "type": "object",
        "description": "A past recording that may be played back.",
        "properties": {
          "name": {
            "type": "string"
          },
          "format": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "format"
        ],
        "x-source-api": "recordings"
      },
      "SystemInfo": {
        "type": "object",
        "description": "Info about Asterisk",
        "properties": {
          "version": {
            "type": "string",
            "description": "Asterisk version."
          },
          "entity_id": {
            "type": "string"
          }
        },
        "required": [
          "version",
          "entity_id"
        ],
        "x-source-api": "asterisk"
      },
      "TextMessage": {
        "type": "object",
        "description": "A text message.",
        "properties": {
          "from": {
            "type": "string",
            "description": "A technology specific URI specifying the source of the message. For pjsip technology, any SIP URI can be specified. For xmpp, the URI must correspond to the client connection being used to send the message."
          },
          "to": {
            "type": "string",
            "description": "A technology specific URI specifying the destination of the message. Valid technologies include pjsip, and xmp. The destination of a message should be an endpoint."
          },
          "body": {
            "type": "string",
            "description": "The text of the message."
          },
          "variables": {
            "type": "object",
            "additionalProperties": true,
            "description": "Technology specific key/value pairs (JSON object) associated with the message."
          }
        },
        "required": [
          "from",
          "to",
          "body"
        ],
        "x-source-api": "endpoints"
      },
      "TextMessageReceived": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Event"
          },
          {
            "type": "object",
            "properties": {
              "message": {
                "$ref": "#/components/schemas/TextMessage"
              },
              "endpoint": {
                "$ref": "#/components/schemas/Endpoint"
              },
              "type": {
                "type": "string",
                "const": "TextMessageReceived"
              }
            },
            "required": [
              "message"
            ]
          }
        ],
        "description": "A text message was received from an endpoint.",
        "x-source-api": "events"
      },
      "Variable": {
        "type": "object",
        "description": "The value of a channel variable",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value of the variable requested"
          }
        },
        "required": [
          "value"
        ],
        "x-source-api": "asterisk"
      },
      "VariableBag": {
        "type": "object",
        "description": "Container for key/value variable pairs",
        "properties": {
          "variables": {
            "type": "object",
            "description": "Key/value pairs of variables",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ]
}